//! Aider agent deployer
//!
//! Handles deployment of AGENTS.md reference to Aider configuration.

use std::fs;
use std::path::PathBuf;

use crate::deployment::deployer::{
    AgentDeployer, AgentStatus, DeploymentConfig, DeploymentOutput,
    PreparedDeployment, TargetLevel, ValidationReport,
};
use crate::deployment::error::{DeploymentError, DeploymentResult};
use crate::deployment::project::ProjectDetector;
use crate::deployment::state::DeploymentState;
use crate::deployment::validator::DeploymentValidator;
use crate::deployment::{generate_agents_md_content, BaseDeployer};
use crate::fs_manager;
use crate::types::AgentDefinition;

/// Deployer for Aider CLI
pub struct AiderDeployer {
    base: BaseDeployer,
}

impl AiderDeployer {
    pub fn new(agent: AgentDefinition) -> Self {
        Self {
            base: BaseDeployer::new(agent),
        }
    }

    /// Get the Aider config file path (user-level)
    fn get_config_path(&self) -> PathBuf {
        dirs::home_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join(".aider.conf.yml")
    }

    /// Get project-level config path
    fn get_project_config_path(&self, project_root: &PathBuf) -> PathBuf {
        project_root.join(".aider.conf.yml")
    }

    /// Resolve project path from config or detect automatically
    fn resolve_project_path(&self, config: &DeploymentConfig) -> DeploymentResult<PathBuf> {
        if let Some(ref path_str) = config.project_path {
            let path = PathBuf::from(path_str);
            if !path.exists() {
                return Err(DeploymentError::ConfigurationError(format!(
                    "Project path does not exist: {}",
                    path_str
                )));
            }
            if !ProjectDetector::is_valid_project_root(&path) {
                return Err(DeploymentError::ConfigurationError(format!(
                    "Path is not a valid project root: {}",
                    path_str
                )));
            }
            Ok(path)
        } else {
            ProjectDetector::detect_project_root().ok_or_else(|| {
                DeploymentError::ConfigurationError(
                    "No project_path provided and could not detect project root".to_string(),
                )
            })
        }
    }
}

impl AgentDeployer for AiderDeployer {
    fn agent_id(&self) -> &str {
        &self.base.agent().id
    }

    fn agent_definition(&self) -> &AgentDefinition {
        self.base.agent()
    }

    fn prepare(&self, config: &DeploymentConfig) -> DeploymentResult<PreparedDeployment> {
        // Generate AGENTS.md content
        let agents_md_content = generate_agents_md_content(&config.pack_ids, false)?;

        let mut prepared = PreparedDeployment::new(agents_md_content);
        prepared.command_format = "yaml".to_string();

        // Add AGENTS.md path to target_paths for backup
        let agentsmd_home = fs_manager::get_agentsmd_home();
        let agents_md_path = agentsmd_home.join("AGENTS.md");
        prepared.add_target_path(agents_md_path.clone());

        // Create YAML config with AGENTS.md reference
        let yaml_config = format!(
            "# Aider configuration\n\
             # Generated by AgentsToolkit\n\n\
             # Read AGENTS.md rules into context\n\
             read:\n\
               - {}\n\n\
             # Additional configuration\n\
             auto-commits: true\n\
             dirty-commits: true\n",
            agents_md_path.to_string_lossy()
        );

        prepared.add_config_file(".aider.conf.yml".to_string(), yaml_config);
        
        // Branch on target level for destination paths
        match config.target_level {
            TargetLevel::Project => {
                // Project-level deployment: .aider.conf.yml in project root
                let project_root = self.resolve_project_path(config)?;
                let project_config_path = self.get_project_config_path(&project_root);
                prepared.add_target_path(project_config_path);
            }
            TargetLevel::User => {
                // User-level: ~/.aider.conf.yml
                prepared.add_target_path(self.get_config_path());
            }
        }

        Ok(prepared)
    }

    fn validate(&self, prepared: &PreparedDeployment) -> DeploymentResult<ValidationReport> {
        // Aider doesn't have a strict character limit
        let limit = self.character_limit().or(Some(500_000));
        let validation = DeploymentValidator::validate_character_budget(
            &prepared.agents_md_content,
            limit,
        );

        let mut warnings = validation.warnings;
        let mut errors = validation.errors;

        // Validate YAML syntax
        for (name, content) in &prepared.config_files {
            if name.ends_with(".yml") || name.ends_with(".yaml") {
                match serde_yaml::from_str::<serde_yaml::Value>(content) {
                    Ok(_) => {}
                    Err(e) => {
                        errors.push(format!("Invalid YAML in '{}': {}", name, e));
                    }
                }
            }
        }

        // Aider doesn't support custom commands
        if !prepared.commands.is_empty() {
            warnings.push(
                "Aider does not support custom commands. Commands will be ignored.".to_string()
            );
        }

        if !errors.is_empty() {
            return Ok(ValidationReport::failure(errors, validation.budget));
        }

        Ok(ValidationReport::success(validation.budget).with_warnings(warnings))
    }

    fn deploy(&self, prepared: PreparedDeployment, config: &DeploymentConfig) -> DeploymentResult<DeploymentOutput> {
        let mut deployed_files = Vec::new();
        let mut warnings = Vec::new();
        let mut manual_steps = Vec::new();

        // Write AGENTS.md to ~/.agentsmd/
        let agentsmd_home = fs_manager::ensure_agentsmd_dir()
            .map_err(|e| DeploymentError::fs_error(PathBuf::new(), e.to_string()))?;
        let agents_md_path = agentsmd_home.join("AGENTS.md");
        
        fs::write(&agents_md_path, &prepared.agents_md_content).map_err(|e| {
            DeploymentError::fs_error(&agents_md_path, format!("Failed to write AGENTS.md: {}", e))
        })?;
        deployed_files.push(agents_md_path.to_string_lossy().to_string());

        // Determine target config path based on target level
        let target_config_path = match config.target_level {
            TargetLevel::Project => {
                let project_root = self.resolve_project_path(config)?;
                self.get_project_config_path(&project_root)
            }
            TargetLevel::User => self.get_config_path(),
        };

        // Check if config file already exists
        if target_config_path.exists() {
            warnings.push(format!(
                "Config file {} already exists. Backup created.",
                target_config_path.display()
            ));
            
            // Read existing config and merge
            let existing = fs::read_to_string(&target_config_path).unwrap_or_default();
            if !existing.contains(&agents_md_path.to_string_lossy().to_string()) {
                // Append read directive if not present
                manual_steps.push(format!(
                    "Add the following to your {}:\n\n\
                     read:\n\
                       - {}\n",
                    target_config_path.display(),
                    agents_md_path.to_string_lossy()
                ));
            }
        } else {
            // Write new config file
            for (_name, content) in &prepared.config_files {
                fs::write(&target_config_path, content).map_err(|e| {
                    DeploymentError::fs_error(&target_config_path, format!("Failed to write config: {}", e))
                })?;
                deployed_files.push(target_config_path.to_string_lossy().to_string());
            }
        }

        // Add usage instructions
        match config.target_level {
            TargetLevel::Project => {
                manual_steps.push(format!(
                    "Project-level Aider config deployed to {}. Aider will automatically read this file when run from this project.",
                    target_config_path.display()
                ));
            }
            TargetLevel::User => {
                manual_steps.push(
                    "Aider will now read AGENTS.md into context. You can also use:\n\
                     - aider --read ~/.agentsmd/AGENTS.md\n\
                     - Or reference it in chat with /read ~/.agentsmd/AGENTS.md".to_string()
                );
            }
        }

        Ok(DeploymentOutput::success("copy", deployed_files)
            .with_warnings(warnings)
            .with_manual_steps(manual_steps))
    }

    fn rollback(&self, state: &DeploymentState) -> DeploymentResult<()> {
        for file_path in &state.files_created {
            let path = PathBuf::from(file_path);
            if path.exists() && path.is_file() {
                fs::remove_file(&path).map_err(|e| {
                    DeploymentError::RollbackFailed(format!(
                        "Failed to remove {}: {}",
                        file_path, e
                    ))
                })?;
            }
        }

        Ok(())
    }

    fn get_status(&self) -> DeploymentResult<AgentStatus> {
        // Check if aider config exists
        let config_path = self.get_config_path();
        
        if config_path.exists() {
            // Check if it references AGENTS.md
            if let Ok(content) = fs::read_to_string(&config_path) {
                if content.contains("AGENTS.md") || content.contains("agentsmd") {
                    return Ok(AgentStatus::Configured);
                }
            }
            return Ok(AgentStatus::Installed);
        }

        // Aider is a pip package, we can't easily detect if it's installed
        Ok(AgentStatus::NotInstalled)
    }

    fn supports_project_level(&self) -> bool {
        true // Aider supports .aider.conf.yml in projects
    }
}
